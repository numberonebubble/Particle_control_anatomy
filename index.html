<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Anatomical Bio-Metric Interface</title>
    
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/control_utils/control_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.js" crossorigin="anonymous"></script>

    <style>
        body { margin: 0; overflow: hidden; background-color: #050505; font-family: 'Segoe UI', monospace; color: white; }
        #canvas-container { position: absolute; top: 0; left: 0; width: 100%; height: 100%; z-index: 1; }
        
        /* Mirror the video input for natural feel */
        #input-video { position: absolute; opacity: 0; pointer-events: none; transform: scaleX(-1); }
        
        #ui-layer {
            position: absolute; top: 20px; left: 20px; z-index: 10;
            display: flex; flex-direction: column; gap: 10px; pointer-events: none;
        }

        .glass-panel {
            background: rgba(10, 15, 20, 0.8);
            backdrop-filter: blur(12px);
            border: 1px solid rgba(255, 255, 255, 0.15);
            padding: 24px;
            border-radius: 16px;
            width: 340px;
            box-shadow: 0 10px 40px rgba(0,0,0,0.6);
        }

        h1 { margin: 0 0 20px 0; font-size: 0.9rem; letter-spacing: 3px; text-transform: uppercase; color: #88ccff; border-bottom: 1px solid #334; padding-bottom: 10px; }
        
        .hand-label { font-size: 0.7rem; color: #667; margin-bottom: 8px; font-weight: 700; text-transform: uppercase; display: flex; justify-content: space-between; }
        
        .instruction { 
            font-size: 0.85rem; color: #889; margin-bottom: 8px; 
            display: flex; align-items: center; gap: 12px; 
            padding: 6px 10px; border-radius: 6px;
            transition: all 0.3s ease;
        }
        
        .icon-box { width: 18px; height: 18px; border: 1px solid #445; display: flex; align-items: center; justify-content: center; border-radius: 4px; font-size: 10px; }

        .active-state { background: rgba(255,255,255,0.1); color: white; border-left: 3px solid #00d2ff; }
        .active-state b { color: #00d2ff; }

        /* Metric Bar */
        .bar-track { width: 100%; height: 4px; background: #223; border-radius: 2px; overflow: hidden; margin-top: 10px; }
        .bar-fill { height: 100%; width: 0%; background: linear-gradient(90deg, #00d2ff, #fff); transition: width 0.1s; }

        #loading {
            position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%);
            color: white; z-index: 20; font-size: 1.5rem; letter-spacing: 3px; animation: pulse 1.5s infinite;
        }
        @keyframes pulse { 0% { opacity: 0.5; } 50% { opacity: 1; } 100% { opacity: 0.5; } }
    </style>
</head>
<body>

    <div id="loading">GENERATING ANATOMY...</div>

    <div id="ui-layer">
        <div class="glass-panel">
            <h1>Bio-Metric Scanner</h1>
            
            <div style="margin-bottom: 25px;">
                <div class="hand-label">
                    <span>Left Hand</span>
                    <span>SHAPE SELECTOR</span>
                </div>
                <div id="state-patient" class="instruction">
                    <div class="icon-box">✋</div> <span>Open: <b>PATIENT</b></span>
                </div>
                <div id="state-medic" class="instruction">
                    <div class="icon-box">✊</div> <span>Fist: <b>MEDIC</b></span>
                </div>
                <div id="state-balloon" class="instruction">
                    <div class="icon-box">☝️</div> <span>Point: <b>BALLOON</b></span>
                </div>
            </div>

            <div>
                <div class="hand-label">
                    <span>Right Hand</span>
                    <span>MATTER CONDENSER</span>
                </div>
                <div class="instruction" style="justify-content: space-between; background:none; padding:0;">
                    <span style="font-size:0.7rem">SCATTER</span>
                    <span style="font-size:0.7rem">CONDENSE</span>
                </div>
                <div class="bar-track">
                    <div id="tension-bar" class="bar-fill"></div>
                </div>
            </div>
            
        </div>
    </div>

    <div id="canvas-container"></div>
    <video id="input-video" playsinline></video>

<script>
    // --- Configuration ---
    const PARTICLE_COUNT = 24000; // Increased for better anatomical density
    
    // --- State Management ---
    const MODES = { PATIENT: 'patient', MEDIC: 'medic', BALLOON: 'balloon' };
    
    let currentShape = MODES.PATIENT; 
    let condensationLevel = 0; 
    
    // Colors
    const COLORS = {
        skin: new THREE.Color(0xdeb887),      // Wheat/Skin
        scrubs: new THREE.Color(0x2E8B57),    // SeaGreen
        balloon: new THREE.Color(0xff3333),   // Red
        string: new THREE.Color(0xffffff)
    };

    let currentColor = COLORS.skin.clone();

    // --- 3D Scene Setup ---
    const container = document.getElementById('canvas-container');
    const scene = new THREE.Scene();
    scene.fog = new THREE.FogExp2(0x050505, 0.025);

    const camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.1, 100);
    camera.position.set(0, 0, 12);

    const renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
    renderer.setSize(window.innerWidth, window.innerHeight);
    renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
    container.appendChild(renderer.domElement);

    // --- Particle System ---
    const targets = {
        patient: new Float32Array(PARTICLE_COUNT * 3),
        patientColors: new Float32Array(PARTICLE_COUNT * 3),
        
        medic: new Float32Array(PARTICLE_COUNT * 3),
        medicColors: new Float32Array(PARTICLE_COUNT * 3),
        
        balloon: new Float32Array(PARTICLE_COUNT * 3),
        balloonColors: new Float32Array(PARTICLE_COUNT * 3)
    };

    const chaosPositions = new Float32Array(PARTICLE_COUNT * 3);
    const geometry = new THREE.BufferGeometry();
    const positions = new Float32Array(PARTICLE_COUNT * 3);
    const colors = new Float32Array(PARTICLE_COUNT * 3);
    const randoms = new Float32Array(PARTICLE_COUNT);

    // --- Anatomical Generation Logic ---

    // A helper to define a body part as a capsule (line segment with radius)
    // pA: Start [x,y,z], pB: End [x,y,z], radius, colorObject
    function createLimbParticles(targetPosArr, targetColArr, startIndex, count, pA, pB, radius, colorObj) {
        const vA = new THREE.Vector3(...pA);
        const vB = new THREE.Vector3(...pB);
        const vec = new THREE.Vector3().subVectors(vB, vA);
        const len = vec.length();
        
        for (let i = 0; i < count; i++) {
            const idx = (startIndex + i) * 3;
            
            // Random point along the line
            const t = Math.random();
            const center = new THREE.Vector3().copy(vA).add(vec.clone().multiplyScalar(t));
            
            // Random point in sphere at that line point (creates capsule volume)
            // Rejection sampling for uniform sphere distribution
            let d = new THREE.Vector3();
            do {
                d.set(Math.random()-0.5, Math.random()-0.5, Math.random()-0.5).normalize();
            } while(d.length() === 0);
            
            // Tapering logic for nicer muscles (optional, simple radius here)
            // Slight noise on radius for texture
            const r = radius * Math.cbrt(Math.random()); 
            
            const p = center.add(d.multiplyScalar(r));

            targetPosArr[idx] = p.x;
            targetPosArr[idx+1] = p.y;
            targetPosArr[idx+2] = p.z;

            // Texture/Color variation
            const shadow = 1 - (Math.random() * 0.3); // Fake AO
            targetColArr[idx] = colorObj.r * shadow;
            targetColArr[idx+1] = colorObj.g * shadow;
            targetColArr[idx+2] = colorObj.b * shadow;
        }
    }

    function generateAnatomy() {
        // We divide particles among body parts based on volume approx
        const parts = PARTICLE_COUNT;
        
        // 1. GENERATE PATIENT (Lying Supine on floor Y=-3)
        // Offset: center around x=0, y=-2
        let offset = 0;
        
        const pt_head = 2000; const pt_torso = 6000; const pt_arm = 2000; const pt_leg = 3000;
        
        // Head
        createLimbParticles(targets.patient, targets.patientColors, offset, pt_head, [-0.5, -2, 0], [0.5, -2, 0], 0.65, COLORS.skin); offset += pt_head;
        // Torso
        createLimbParticles(targets.patient, targets.patientColors, offset, pt_torso, [0.6, -2, 0], [2.5, -2, 0], 0.7, COLORS.skin); offset += pt_torso;
        // Right Arm (Flared out)
        createLimbParticles(targets.patient, targets.patientColors, offset, pt_arm, [0.8, -2, 0.7], [2.5, -2, 1.5], 0.25, COLORS.skin); offset += pt_arm;
        // Left Arm
        createLimbParticles(targets.patient, targets.patientColors, offset, pt_arm, [0.8, -2, -0.7], [2.5, -2, -1.5], 0.25, COLORS.skin); offset += pt_arm;
        // Right Leg
        createLimbParticles(targets.patient, targets.patientColors, offset, pt_leg, [2.5, -2, 0.3], [5.0, -2, 0.4], 0.3, COLORS.skin); offset += pt_leg;
        // Left Leg
        createLimbParticles(targets.patient, targets.patientColors, offset, pt_leg, [2.5, -2, -0.3], [5.0, -2, -0.4], 0.3, COLORS.skin); offset += pt_leg;

        // Fill remaining patient particles with noise around body
        while(offset < PARTICLE_COUNT) {
            targets.patient[offset*3] = (Math.random()*6)-1;
            targets.patient[offset*3+1] = -2.5;
            targets.patient[offset*3+2] = (Math.random()*4)-2;
            offset++;
        }

        // 2. GENERATE MEDIC (Kneeling/Leaning over)
        offset = 0;
        // Head (Leaning forward)
        createLimbParticles(targets.medic, targets.medicColors, offset, pt_head, [-1.0, 0.5, 0], [-0.8, 0.3, 0], 0.5, COLORS.skin); offset += pt_head;
        // Torso (Angled down)
        createLimbParticles(targets.medic, targets.medicColors, offset, pt_torso, [-0.6, 0.2, 0], [0.5, -1.0, 0], 0.7, COLORS.scrubs); offset += pt_torso;
        // Thighs (Kneeling vertical-ish)
        createLimbParticles(targets.medic, targets.medicColors, offset, pt_leg, [0.5, -1.0, 0.3], [0.5, -2.5, 0.6], 0.35, COLORS.scrubs); offset += pt_leg;
        createLimbParticles(targets.medic, targets.medicColors, offset, pt_leg, [0.5, -1.0, -0.3], [0.5, -2.5, -0.6], 0.35, COLORS.scrubs); offset += pt_leg;
        // Arms (Reaching down towards patient chest)
        createLimbParticles(targets.medic, targets.medicColors, offset, pt_arm, [-0.5, 0.0, 0.6], [-0.5, -1.5, 0.2], 0.2, COLORS.skin); offset += pt_arm;
        createLimbParticles(targets.medic, targets.medicColors, offset, pt_arm, [-0.5, 0.0, -0.6], [-0.5, -1.5, -0.2], 0.2, COLORS.skin); offset += pt_arm;
        
        // Fill remainder
        while(offset < PARTICLE_COUNT) { offset++; }

        // 3. GENERATE BALLOON (Object + Tether)
        offset = 0;
        const pt_balloon = 18000; 
        const balloonCenter = new THREE.Vector3(0, 1.5, 0);
        
        for(let i=0; i<pt_balloon; i++) {
            // Sphere with specular highlight logic in color
            const idx = (offset + i) * 3;
            // Uniform sphere
            const u = Math.random(), v = Math.random();
            const theta = 2 * Math.PI * u;
            const phi = Math.acos(2 * v - 1);
            const r = 1.2 * Math.cbrt(Math.random()); // Radius 1.2
            
            const px = balloonCenter.x + r * Math.sin(phi) * Math.cos(theta);
            const py = balloonCenter.y + r * Math.sin(phi) * Math.sin(theta);
            const pz = balloonCenter.z + r * Math.cos(phi);
            
            targets.balloon[idx] = px; targets.balloon[idx+1] = py; targets.balloon[idx+2] = pz;
            
            // Fake Specular Highlight: if point is top-right-front, make it white
            // Light source approx (1, 1, 1)
            const normal = new THREE.Vector3(px - balloonCenter.x, py - balloonCenter.y, pz - balloonCenter.z).normalize();
            const light = new THREE.Vector3(0.5, 1, 0.8).normalize();
            const dot = Math.max(0, normal.dot(light));
            const spec = Math.pow(dot, 20); // Shininess
            
            targets.balloonColors[idx] = Math.min(1, COLORS.balloon.r + spec);
            targets.balloonColors[idx+1] = Math.min(1, COLORS.balloon.g + spec);
            targets.balloonColors[idx+2] = Math.min(1, COLORS.balloon.b + spec);
        }
        offset += pt_balloon;

        // String
        const pt_string = PARTICLE_COUNT - offset;
        createLimbParticles(targets.balloon, targets.balloonColors, offset, pt_string, [0, 1.5-1.2, 0], [0.8, -2, 0], 0.05, COLORS.string);
    }

    generateAnatomy();

    // Init Chaos
    for(let i=0; i<PARTICLE_COUNT; i++) {
        const theta = Math.random() * Math.PI * 2;
        const phi = Math.acos(Math.random() * 2 - 1);
        const r = 8 + Math.random() * 10;
        
        chaosPositions[i*3] = r * Math.sin(phi) * Math.cos(theta);
        chaosPositions[i*3+1] = r * Math.sin(phi) * Math.sin(theta);
        chaosPositions[i*3+2] = r * Math.cos(phi);
        
        positions[i*3] = chaosPositions[i*3];
        positions[i*3+1] = chaosPositions[i*3+1];
        positions[i*3+2] = chaosPositions[i*3+2];
        
        colors[i*3] = 0.1; colors[i*3+1] = 0.1; colors[i*3+2] = 0.1;
        randoms[i] = Math.random();
    }

    geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
    geometry.setAttribute('color', new THREE.BufferAttribute(colors, 3));

    const material = new THREE.PointsMaterial({
        size: 0.06, vertexColors: true, transparent: true, opacity: 0.9, blending: THREE.AdditiveBlending, depthWrite: false
    });
    const particles = new THREE.Points(geometry, material);
    scene.add(particles);

    // --- MediaPipe Logic ---
    const videoElement = document.getElementById('input-video');

    function calculateTension(landmarks) {
        const wrist = landmarks[0];
        const tips = [8, 12, 16, 20];
        let avgDist = 0;
        tips.forEach(idx => {
            avgDist += Math.hypot(landmarks[idx].x - wrist.x, landmarks[idx].y - wrist.y);
        });
        avgDist /= 4;
        // Map: Open (~0.4) -> 0, Closed (~0.15) -> 1
        return Math.max(0, Math.min(1, (0.45 - avgDist) * 3.5));
    }

    function determineGesture(landmarks) {
        const isExtended = (tip, pip) => {
            return Math.hypot(landmarks[tip].x - landmarks[0].x, landmarks[tip].y - landmarks[0].y) > 
                   Math.hypot(landmarks[pip].x - landmarks[0].x, landmarks[pip].y - landmarks[0].y);
        };
        const fingers = [isExtended(8,6), isExtended(12,10), isExtended(16,14), isExtended(20,18)];
        const count = fingers.filter(Boolean).length;

        if (count >= 4) return MODES.PATIENT;
        if (count === 0) return MODES.MEDIC;
        if (fingers[0] && !fingers[1]) return MODES.BALLOON;
        return null;
    }

    function onResults(results) {
        let rightHandDetected = false;

        if (results.multiHandLandmarks) {
            for (let i = 0; i < results.multiHandLandmarks.length; i++) {
                const label = results.multiHandedness[i].label;
                const landmarks = results.multiHandLandmarks[i];

                // --- MIRROR ADJUSTMENT LOGIC ---
                // MediaPipe "Left" = Physical Left Hand.
                // MediaPipe "Right" = Physical Right Hand.
                // We map Physical Left to Selection, Physical Right to Condensation.

                if (label === 'Left') {
                    // SHAPE SELECTOR
                    const shape = determineGesture(landmarks);
                    if (shape) {
                        currentShape = shape;
                        // UI Update
                        document.querySelectorAll('.instruction').forEach(el => el.classList.remove('active-state'));
                        document.getElementById(`state-${currentShape}`).classList.add('active-state');
                    }
                } 
                else if (label === 'Right') {
                    // CONDENSER
                    rightHandDetected = true;
                    const tension = calculateTension(landmarks);
                    // Smooth transition
                    condensationLevel += (tension - condensationLevel) * 0.15;
                    document.getElementById('tension-bar').style.width = `${condensationLevel * 100}%`;
                }
            }
        }

        if (!rightHandDetected) {
            condensationLevel *= 0.95; // Decay if hand lost
            document.getElementById('tension-bar').style.width = `${condensationLevel * 100}%`;
        }
    }

    const hands = new Hands({locateFile: (file) => `https://cdn.jsdelivr.net/npm/@mediapipe/hands/${file}`});
    hands.setOptions({ maxNumHands: 2, modelComplexity: 1, minDetectionConfidence: 0.5, minTrackingConfidence: 0.5 });
    hands.onResults(onResults);

    const cameraUtils = new Camera(videoElement, {
        onFrame: async () => { await hands.send({image: videoElement}); },
        width: 640, height: 480
    });
    cameraUtils.start().then(() => document.getElementById('loading').style.display = 'none');

    // --- Loop ---
    let time = 0;
    function animate() {
        requestAnimationFrame(animate);
        time += 0.01;

        const posArr = geometry.attributes.position.array;
        const colArr = geometry.attributes.color.array;

        // Select Target Arrays
        let tPos, tCol;
        if(currentShape === MODES.PATIENT) { tPos = targets.patient; tCol = targets.patientColors; }
        else if(currentShape === MODES.MEDIC) { tPos = targets.medic; tCol = targets.medicColors; }
        else { tPos = targets.balloon; tCol = targets.balloonColors; }

        for (let i = 0; i < PARTICLE_COUNT; i++) {
            const ix = i * 3, iy = i * 3 + 1, iz = i * 3 + 2;

            // Target Position based on Condensation
            const tx = chaosPositions[ix] + (tPos[ix] - chaosPositions[ix]) * condensationLevel;
            const ty = chaosPositions[iy] + (tPos[iy] - chaosPositions[iy]) * condensationLevel;
            const tz = chaosPositions[iz] + (tPos[iz] - chaosPositions[iz]) * condensationLevel;

            // Target Color
            const targetR = tCol[ix];
            const targetG = tCol[iy];
            const targetB = tCol[iz];

            // Physics Update
            const speed = 0.1 + (randoms[i] * 0.05);
            
            posArr[ix] += (tx - posArr[ix]) * speed;
            posArr[iy] += (ty - posArr[iy]) * speed;
            posArr[iz] += (tz - posArr[iz]) * speed;

            // Color Blending (Slow fade to target color)
            colArr[ix] += (targetR - colArr[ix]) * 0.05;
            colArr[iy] += (targetG - colArr[iy]) * 0.05;
            colArr[iz] += (targetB - colArr[iz]) * 0.05;
            
            // Jitter when loose
            if(condensationLevel < 0.9) {
                const noise = 0.02 * (1 - condensationLevel);
                posArr[ix] += (Math.random()-0.5)*noise;
                posArr[iy] += (Math.random()-0.5)*noise;
                posArr[iz] += (Math.random()-0.5)*noise;
            }
        }

        geometry.attributes.position.needsUpdate = true;
        geometry.attributes.color.needsUpdate = true;
        
        // Dynamic Camera Rotation
        const rot = Math.sin(time * 0.2) * 0.2;
        scene.rotation.y = rot;

        renderer.render(scene, camera);
    }

    animate();
    window.addEventListener('resize', () => {
        camera.aspect = window.innerWidth / window.innerHeight;
        camera.updateProjectionMatrix();
        renderer.setSize(window.innerWidth, window.innerHeight);
    });

</script>
</body>
</html>
