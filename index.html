<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Emergency Scene - Bio-Particles</title>
    
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/control_utils/control_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/drawing_utils/drawing_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.js" crossorigin="anonymous"></script>

    <style>
        body { margin: 0; overflow: hidden; background-color: #050505; font-family: sans-serif; color: white; }
        #canvas-container { position: absolute; top: 0; left: 0; width: 100%; height: 100%; z-index: 1; }
        #input-video { position: absolute; opacity: 0; pointer-events: none; }
        
        #ui-layer {
            position: absolute; top: 20px; left: 20px; z-index: 10;
            display: flex; flex-direction: column; gap: 10px; pointer-events: none;
        }

        .glass-panel {
            background: rgba(20, 20, 30, 0.6);
            backdrop-filter: blur(10px);
            border: 1px solid rgba(255, 255, 255, 0.1);
            padding: 20px;
            border-radius: 12px;
            width: 280px;
        }

        h1 { margin: 0 0 10px 0; font-size: 1.1rem; letter-spacing: 2px; text-transform: uppercase; color: #fff; border-bottom: 1px solid #444; padding-bottom: 5px; }
        .instruction { font-size: 0.85rem; color: #aaa; margin-bottom: 5px; display: flex; align-items: center; gap: 10px; }
        .color-dot { width: 10px; height: 10px; border-radius: 50%; display: inline-block; }
        
        .active-state { color: white; font-weight: bold; text-shadow: 0 0 10px white; }

        #loading {
            position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%);
            color: white; z-index: 20; font-size: 1.5rem; letter-spacing: 3px; animation: pulse 1.5s infinite;
        }
        @keyframes pulse { 0% { opacity: 0.5; } 50% { opacity: 1; } 100% { opacity: 0.5; } }
    </style>
</head>
<body>

    <div id="loading">LOADING SCENE...</div>

    <div id="ui-layer">
        <div class="glass-panel">
            <h1>Emergency Scene</h1>
            
            <div id="state-patient" class="instruction">
                <span class="color-dot" style="background:#00d2ff"></span>
                <span>Open Hand: <b>PATIENT</b></span>
            </div>
            
            <div id="state-medic" class="instruction">
                <span class="color-dot" style="background:#00ff88"></span>
                <span>Fist: <b>MEDIC</b></span>
            </div>

            <div id="state-balloon" class="instruction">
                <span class="color-dot" style="background:#ff3333"></span>
                <span>Point Finger: <b>BALLOON</b></span>
            </div>
            
            <div style="margin-top:15px; font-size:0.8rem; color:#666; border-top:1px solid #333; padding-top:10px;">
                Status: <span id="status-text">Detecting...</span>
            </div>
        </div>
    </div>

    <div id="canvas-container"></div>
    <video id="input-video" playsinline></video>

<script>
    // --- Configuration ---
    const PARTICLE_COUNT = 15000;
    
    // --- State Management ---
    const MODES = {
        PATIENT: 'patient',
        MEDIC: 'medic',
        BALLOON: 'balloon',
        IDLE: 'idle'
    };
    
    let currentMode = MODES.IDLE;
    let targetMode = MODES.PATIENT; // Default start
    let transitionProgress = 0; // 0 to 1

    // Colors
    const COLORS = {
        patient: new THREE.Color(0x00d2ff), // Cyan
        medic: new THREE.Color(0x00ff88),   // Medic Green
        balloon: new THREE.Color(0xff3333)  // Alert Red
    };

    let currentColor = COLORS.patient.clone();
    let targetColor = COLORS.patient.clone();

    // --- 3D Scene Setup ---
    const container = document.getElementById('canvas-container');
    const scene = new THREE.Scene();
    scene.fog = new THREE.FogExp2(0x050505, 0.02);

    const camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.1, 100);
    camera.position.set(0, 1, 10);
    camera.lookAt(0, 0, 0);

    const renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
    renderer.setSize(window.innerWidth, window.innerHeight);
    container.appendChild(renderer.domElement);

    // --- Particle System ---
    
    // Arrays to hold different shape coordinates
    const targets = {
        patient: new Float32Array(PARTICLE_COUNT * 3),
        medic: new Float32Array(PARTICLE_COUNT * 3),
        balloon: new Float32Array(PARTICLE_COUNT * 3)
    };

    const geometry = new THREE.BufferGeometry();
    const positions = new Float32Array(PARTICLE_COUNT * 3);
    const colors = new Float32Array(PARTICLE_COUNT * 3);
    const randoms = new Float32Array(PARTICLE_COUNT * 3);

    // --- Geometry Generators ---

    // 1. Helper: Tapered Cylinder
    function getCylinderPoint(rTop, rBot, height, yCenter, xOffset=0, zOffset=0, axis='y') {
        const v = Math.random() - 0.5; 
        const hPos = v * height;
        const t = v + 0.5;
        const rCurrent = rBot + (rTop - rBot) * t;
        const theta = Math.random() * 2 * Math.PI;
        const r = Math.sqrt(Math.random()) * rCurrent;

        let p = { x:0, y:0, z:0 };

        if (axis === 'y') {
            // Standing up
            p.x = xOffset + r * Math.cos(theta);
            p.y = yCenter + hPos;
            p.z = zOffset + r * Math.sin(theta);
        } else if (axis === 'x') {
            // Lying down (Patient)
            p.x = xOffset + hPos; // Length is along X
            p.y = yCenter + r * Math.cos(theta);
            p.z = zOffset + r * Math.sin(theta);
        }
        return p;
    }

    // 2. Generator: PATIENT (Lying down at Y = -2)
    function generatePatient() {
        for (let i = 0; i < PARTICLE_COUNT; i++) {
            let p;
            const r = Math.random();
            const yLevel = -2.0; // Floor level

            if (r < 0.1) { // Head (Sphere-ish)
                const u = Math.random(), v = Math.random();
                const theta = 2 * Math.PI * u, phi = Math.acos(2 * v - 1);
                const rad = 0.5 * Math.cbrt(Math.random());
                p = {
                    x: -2.5 + rad * Math.sin(phi) * Math.cos(theta), // Head at left
                    y: yLevel + rad * Math.sin(phi) * Math.sin(theta),
                    z: rad * Math.cos(phi)
                };
            } else if (r < 0.4) { // Torso (Lying X axis)
                p = getCylinderPoint(0.7, 0.6, 2.0, -1.0, -1.0, 0, 'x'); // Center X approx -1
                p.y += (yLevel - -1.0); // Adjust to floor
            } else if (r < 0.9) { // Legs (Lying X axis)
                p = getCylinderPoint(0.3, 0.2, 2.5, 1.5, 1.5, 0, 'x');
                p.y += (yLevel - 1.5);
            } else { // Arms (Lying beside body)
                p = getCylinderPoint(0.15, 0.1, 2.0, -1.0, -1.0, 0.8, 'x'); // Arm offset Z
                p.y += (yLevel - -1.0);
            }
            
            targets.patient[i*3] = p.x;
            targets.patient[i*3+1] = p.y;
            targets.patient[i*3+2] = p.z;
        }
    }

    // 3. Generator: MEDIC (Leaning over patient)
    function generateMedic() {
        for (let i = 0; i < PARTICLE_COUNT; i++) {
            let p;
            const r = Math.random();
            // Medic stands slightly offset in Z and X, leaning towards patient chest
            const xOff = -0.5; 
            const zOff = -1.5; 

            if (r < 0.08) { // Head
                const u = Math.random(), v = Math.random();
                const theta = 2 * Math.PI * u, phi = Math.acos(2 * v - 1);
                const rad = 0.45 * Math.cbrt(Math.random());
                p = { // Leaning forward head
                    x: xOff + rad * Math.sin(phi) * Math.cos(theta),
                    y: 0.5 + rad * Math.sin(phi) * Math.sin(theta), 
                    z: zOff + 1.0 + rad * Math.cos(phi) // Leaning in Z
                };
            } else if (r < 0.4) { // Torso (Angled)
                // Approximating a leaning torso by tilting a cylinder manually
                const raw = getCylinderPoint(0.6, 0.5, 1.5, 0, 0, 0, 'y');
                // Rotate around X axis to lean forward
                const angle = 0.5; // Radians lean
                p = {
                    x: xOff + raw.x,
                    y: (raw.y * Math.cos(angle) - raw.z * Math.sin(angle)) - 0.5,
                    z: zOff + (raw.y * Math.sin(angle) + raw.z * Math.cos(angle))
                };
            } else if (r < 0.7) { // Legs (Kneeling-ish)
                p = getCylinderPoint(0.25, 0.2, 1.5, -1.5, xOff-0.3, zOff, 'y');
            } else { // Arms (Reaching down)
                const raw = getCylinderPoint(0.15, 0.12, 1.2, -0.2, 0, 0, 'y');
                 // Reach forward
                 const angle = 1.0; 
                 p = {
                    x: xOff + raw.x,
                    y: (raw.y * Math.cos(angle) - raw.z * Math.sin(angle)) + 0.5,
                    z: zOff + (raw.y * Math.sin(angle) + raw.z * Math.cos(angle)) + 0.5
                };
            }
            targets.medic[i*3] = p.x;
            targets.medic[i*3+1] = p.y;
            targets.medic[i*3+2] = p.z;
        }
    }

    // 4. Generator: BALLOON (Attached to Chest)
    function generateBalloon() {
        for (let i = 0; i < PARTICLE_COUNT; i++) {
            let p;
            const r = Math.random();
            // Patient Chest is approx x=-1, y=-2, z=0
            const chestX = -1.0;
            const chestY = -1.8;
            const balloonHeight = 1.5; // Floating height

            if (r < 0.7) { // The Balloon Sphere
                const u = Math.random(), v = Math.random();
                const theta = 2 * Math.PI * u, phi = Math.acos(2 * v - 1);
                const rad = 0.8 * Math.cbrt(Math.random()); // Large sphere
                p = {
                    x: chestX + rad * Math.sin(phi) * Math.cos(theta),
                    y: balloonHeight + rad * Math.sin(phi) * Math.sin(theta), 
                    z: rad * Math.cos(phi)
                };
            } else { // The String (Line from chest to balloon)
                const t = Math.random(); // 0 to 1
                p = {
                    x: chestX + (Math.random()-0.5)*0.05, // Slight jitter thickness
                    y: chestY + (balloonHeight - chestY) * t,
                    z: (Math.random()-0.5)*0.05
                };
            }
            targets.balloon[i*3] = p.x;
            targets.balloon[i*3+1] = p.y;
            targets.balloon[i*3+2] = p.z;
        }
    }

    // Initialize Arrays
    generatePatient();
    generateMedic();
    generateBalloon();

    // Fill initial positions (Exploded)
    for(let i=0; i<PARTICLE_COUNT*3; i++) {
        positions[i] = (Math.random()-0.5) * 20;
        randoms[i] = Math.random();
        colors[i] = currentColor.r; // Initialize with start color R component (simple fill)
    }
    
    // Correct color initialization
    for(let i=0; i<PARTICLE_COUNT; i++) {
        colors[i*3] = currentColor.r;
        colors[i*3+1] = currentColor.g;
        colors[i*3+2] = currentColor.b;
    }

    geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
    geometry.setAttribute('color', new THREE.BufferAttribute(colors, 3));

    // Particle Material
    const material = new THREE.PointsMaterial({
        size: 0.12,
        vertexColors: true,
        transparent: true,
        opacity: 0.8,
        blending: THREE.AdditiveBlending,
        depthWrite: false
    });

    const particles = new THREE.Points(geometry, material);
    scene.add(particles);

    // --- MediaPipe Logic ---
    const videoElement = document.getElementById('input-video');

    function determineGesture(landmarks) {
        // Simple logic based on finger extension
        // Tips: 8 (Index), 12 (Middle), 16 (Ring), 20 (Pinky)
        // PIPs: 6, 10, 14, 18 (Knuckles)
        
        const isExtended = (tipIdx, pipIdx) => {
            // Check distance from wrist(0)
            const dTip = Math.hypot(landmarks[tipIdx].x - landmarks[0].x, landmarks[tipIdx].y - landmarks[0].y);
            const dPip = Math.hypot(landmarks[pipIdx].x - landmarks[0].x, landmarks[pipIdx].y - landmarks[0].y);
            return dTip > dPip; // Basic check
        };

        const indexOut = isExtended(8, 6);
        const middleOut = isExtended(12, 10);
        const ringOut = isExtended(16, 14);
        const pinkyOut = isExtended(20, 18);

        const extendedCount = [indexOut, middleOut, ringOut, pinkyOut].filter(Boolean).length;

        if (extendedCount === 4) return MODES.PATIENT; // Open hand
        if (extendedCount === 0) return MODES.MEDIC;   // Fist
        if (indexOut && !middleOut && !ringOut && !pinkyOut) return MODES.BALLOON; // Pointing
        if (indexOut && middleOut && !ringOut && !pinkyOut) return MODES.BALLOON; // Peace sign also accepts as balloon
        
        return MODES.PATIENT; // Default fallback
    }

    function onResults(results) {
        if (results.multiHandLandmarks && results.multiHandLandmarks.length > 0) {
            const landmarks = results.multiHandLandmarks[0]; // Use first hand
            const detectedMode = determineGesture(landmarks);
            
            // Debounce/Smooth transitions could go here, but direct setting is fine for responsiveness
            if (detectedMode !== currentMode) {
                targetMode = detectedMode;
                // Update UI highlighting
                document.querySelectorAll('.instruction').forEach(el => el.classList.remove('active-state'));
                document.getElementById(`state-${targetMode}`).classList.add('active-state');
                document.getElementById('status-text').innerText = targetMode.toUpperCase();
            }

            // Set Target Color
            if(targetMode === MODES.PATIENT) targetColor = COLORS.patient;
            if(targetMode === MODES.MEDIC) targetColor = COLORS.medic;
            if(targetMode === MODES.BALLOON) targetColor = COLORS.balloon;

        }
    }

    const hands = new Hands({locateFile: (file) => `https://cdn.jsdelivr.net/npm/@mediapipe/hands/${file}`});
    hands.setOptions({ maxNumHands: 1, modelComplexity: 1, minDetectionConfidence: 0.5, minTrackingConfidence: 0.5 });
    hands.onResults(onResults);

    const cameraUtils = new Camera(videoElement, {
        onFrame: async () => { await hands.send({image: videoElement}); },
        width: 640, height: 480
    });
    cameraUtils.start().then(() => document.getElementById('loading').style.display = 'none');

    // --- Animation Loop ---
    
    let time = 0;

    function animate() {
        requestAnimationFrame(animate);
        time += 0.01;

        // Smooth Color Transition
        currentColor.lerp(targetColor, 0.05);

        const posArr = geometry.attributes.position.array;
        const colArr = geometry.attributes.color.array;

        // Determine which target array to use
        let targetArr;
        if(targetMode === MODES.PATIENT) targetArr = targets.patient;
        else if(targetMode === MODES.MEDIC) targetArr = targets.medic;
        else targetArr = targets.balloon;

        // Particle Physics
        for (let i = 0; i < PARTICLE_COUNT; i++) {
            const ix = i * 3, iy = i * 3 + 1, iz = i * 3 + 2;

            const tx = targetArr[ix];
            const ty = targetArr[iy];
            const tz = targetArr[iz];

            let cx = posArr[ix];
            let cy = posArr[iy];
            let cz = posArr[iz];

            // Attraction Force (Move to target shape)
            // Faster reaction than previous version for clearer gesture swapping
            const speed = 0.08 + (randoms[ix] * 0.02); 
            
            cx += (tx - cx) * speed;
            cy += (ty - cy) * speed;
            cz += (tz - cz) * speed;

            // Add Idle Noise (Breathing effect)
            const noise = 0.02;
            cx += Math.sin(time + randoms[iy]*10) * noise;
            cy += Math.cos(time + randoms[ix]*10) * noise;

            // Update Arrays
            posArr[ix] = cx;
            posArr[iy] = cy;
            posArr[iz] = cz;

            // Update Colors
            colArr[ix] = currentColor.r + (Math.random() * 0.1);
            colArr[iy] = currentColor.g + (Math.random() * 0.1);
            colArr[iz] = currentColor.b + (Math.random() * 0.1);
        }

        geometry.attributes.position.needsUpdate = true;
        geometry.attributes.color.needsUpdate = true;
        
        // Gentle scene rotation
        particles.rotation.y = Math.sin(time * 0.1) * 0.1;

        renderer.render(scene, camera);
    }

    animate();
    
    // Resize Handle
    window.addEventListener('resize', () => {
        camera.aspect = window.innerWidth / window.innerHeight;
        camera.updateProjectionMatrix();
        renderer.setSize(window.innerWidth, window.innerHeight);
    });

</script>
</body>
</html>
