<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>FFT Bio-Particle System</title>
    <style>
        body { margin: 0; overflow: hidden; background-color: #000; font-family: 'Courier New', monospace; }
        
        /* 3D Canvas */
        #canvas-container { position: absolute; top: 0; left: 0; width: 100%; height: 100%; z-index: 1; }

        /* HUD Overlay */
        #hud {
            position: absolute; top: 20px; right: 20px; z-index: 10;
            color: #00ffcc; text-align: right; pointer-events: none;
        }
        .hud-panel {
            background: rgba(0, 20, 20, 0.8);
            border: 1px solid #00ffcc;
            padding: 15px;
            margin-bottom: 10px;
            border-radius: 4px;
        }
        .label { font-size: 10px; opacity: 0.7; text-transform: uppercase; letter-spacing: 1px; }
        .big-value { font-size: 42px; font-weight: bold; color: #ff3366; text-shadow: 0 0 10px rgba(255, 51, 102, 0.5); }
        .graph-container { width: 200px; height: 60px; background: #001111; border: 1px solid #004444; margin-top: 5px; position: relative; }
        canvas.mini-graph { width: 100%; height: 100%; display: block; }

        /* Webcam Feed */
        #cam-container {
            position: absolute; bottom: 20px; right: 20px; z-index: 10;
            width: 200px; height: 150px;
            border: 1px solid #333;
            background: #000;
        }
        #input-video {
            width: 100%; height: 100%; object-fit: cover;
            transform: scaleX(-1);
            opacity: 0.6;
        }
        #overlay-canvas {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            transform: scaleX(-1);
        }

        #loader {
            position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%);
            color: #00ffcc; z-index: 20; font-size: 16px;
            animation: blink 1s infinite;
        }
        @keyframes blink { 50% { opacity: 0.5; } }
    </style>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/face_mesh/face_mesh.js"></script>
</head>
<body>

    <div id="loader">INITIALIZING SENSORS...</div>

    <div id="hud">
        <div class="hud-panel">
            <div class="label">Est. Heart Rate (FFT)</div>
            <div class="big-value" id="bpm-display">--</div>
            <div class="label" id="status-display">NO SIGNAL</div>
        </div>
        <div class="hud-panel">
            <div class="label">Raw Signal</div>
            <div class="graph-container">
                <canvas id="signal-graph" width="200" height="60"></canvas>
            </div>
            <div class="label" style="margin-top: 5px;">Frequency Spectrum</div>
            <div class="graph-container">
                <canvas id="fft-graph" width="200" height="60"></canvas>
            </div>
        </div>
    </div>

    <div id="cam-container">
        <video id="input-video" playsinline></video>
        <canvas id="overlay-canvas"></canvas>
    </div>

    <div id="canvas-container"></div>

<script>
/**
 * SECTION 1: MATH & FFT (The Signal Processing Core)
 * Custom implementation of Cooley-Tukey FFT algorithm
 */

// Complex Number Helper
class Complex {
    constructor(re, im) { this.re = re; this.im = im; }
    add(other) { return new Complex(this.re + other.re, this.im + other.im); }
    sub(other) { return new Complex(this.re - other.re, this.im - other.im); }
    mul(other) { return new Complex(this.re * other.re - this.im * other.im, this.re * other.im + this.im * other.re); }
}

// Bit-reverse copy for FFT
function bitReverseArray(input) {
    const n = input.length;
    const output = new Array(n);
    let k = Math.log2(n);
    for (let i = 0; i < n; i++) {
        let rev = 0;
        let temp = i;
        for (let j = 0; j < k; j++) {
            rev = (rev << 1) | (temp & 1);
            temp >>= 1;
        }
        output[rev] = input[i];
    }
    return output;
}

// Iterative FFT Implementation
function computeFFT(inputData) {
    const n = inputData.length;
    let a = bitReverseArray(inputData.map(v => new Complex(v, 0))); // Convert real to complex

    for (let len = 2; len <= n; len <<= 1) {
        let angle = -2 * Math.PI / len;
        let wlen = new Complex(Math.cos(angle), Math.sin(angle));
        for (let i = 0; i < n; i += len) {
            let w = new Complex(1, 0);
            for (let j = 0; j < len / 2; j++) {
                let u = a[i + j];
                let v = a[i + j + len / 2].mul(w);
                a[i + j] = u.add(v);
                a[i + j + len / 2] = u.sub(v);
                w = w.mul(wlen);
            }
        }
    }
    // Return magnitudes
    return a.map(c => Math.sqrt(c.re * c.re + c.im * c.im));
}

// Linear Interpolation for resampling uneven timestamps
function lerp(v0, v1, t) { return v0 * (1 - t) + v1 * t; }

/**
 * SECTION 2: THREE.JS PARTICLE SYSTEM
 */
const scene = new THREE.Scene();
scene.fog = new THREE.FogExp2(0x000000, 0.002);
const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
camera.position.z = 35;

const renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
renderer.setSize(window.innerWidth, window.innerHeight);
document.getElementById('canvas-container').appendChild(renderer.domElement);

// Particle Setup
const particleCount = 20000;
const pGeom = new THREE.BufferGeometry();
const pPos = new Float32Array(particleCount * 3);
const pCol = new Float32Array(particleCount * 3);
const pTarget = new Float32Array(particleCount * 3);
const pRandom = new Float32Array(particleCount * 3);

// Colors
const colHeart = new THREE.Color(0xff0044);
const colOpen = new THREE.Color(0x00aaff);

// Init Geometry
for (let i = 0; i < particleCount; i++) {
    // 1. Heart Shape (Math)
    // x = 16sin^3(t)
    // y = 13cos(t) - 5cos(2t) - 2cos(3t) - cos(4t)
    const t = Math.random() * Math.PI * 2;
    const jitter = Math.random();
    
    let hx = 16 * Math.pow(Math.sin(t), 3);
    let hy = 13 * Math.cos(t) - 5 * Math.cos(2 * t) - 2 * Math.cos(3 * t) - Math.cos(4 * t);
    let hz = (Math.random() - 0.5) * 8; 

    // Add volumetric scatter to heart
    hx += (Math.random() - 0.5) * 1.5;
    hy += (Math.random() - 0.5) * 1.5;

    pTarget[i*3] = hx * 0.5;
    pTarget[i*3+1] = hy * 0.5;
    pTarget[i*3+2] = hz * 0.5;

    // 2. Exploded Shape
    pRandom[i*3] = (Math.random() - 0.5) * 80;
    pRandom[i*3+1] = (Math.random() - 0.5) * 80;
    pRandom[i*3+2] = (Math.random() - 0.5) * 50;

    // Start random
    pPos[i*3] = pRandom[i*3];
    pPos[i*3+1] = pRandom[i*3+1];
    pPos[i*3+2] = pRandom[i*3+2];

    pCol[i*3] = colOpen.r;
    pCol[i*3+1] = colOpen.g;
    pCol[i*3+2] = colOpen.b;
}

pGeom.setAttribute('position', new THREE.BufferAttribute(pPos, 3));
pGeom.setAttribute('color', new THREE.BufferAttribute(pCol, 3));

const pMat = new THREE.PointsMaterial({
    size: 0.15, vertexColors: true, blending: THREE.AdditiveBlending, depthTest: false, transparent: true, opacity: 0.8
});
const particleSystem = new THREE.Points(pGeom, pMat);
scene.add(particleSystem);


/**
 * SECTION 3: SENSORS & SIGNAL PROCESSING LOOP
 */

// --- Variables ---
let handTension = 0; // 0 (Open) to 1 (Fist)
let detectedBPM = 0;
let lastPulseTime = 0;

// PPG Buffers
const MAX_SAMPLES = 512; // Power of 2 for FFT
const TARGET_FPS = 30;   // Resample signal to 30Hz
let rawGreenBuffer = []; // {t: time, v: value}

// UI Graphs
const signalCtx = document.getElementById('signal-graph').getContext('2d');
const fftCtx = document.getElementById('fft-graph').getContext('2d');

// --- MediaPipe Face (PPG) ---
const faceMesh = new FaceMesh({locateFile: (file) => `https://cdn.jsdelivr.net/npm/@mediapipe/face_mesh/${file}`});
faceMesh.setOptions({maxNumFaces: 1, minDetectionConfidence: 0.5, minTrackingConfidence: 0.5});

// Offscreen canvas for reading pixels
const pxCanvas = document.createElement('canvas');
pxCanvas.width = 50; pxCanvas.height = 50;
const pxCtx = pxCanvas.getContext('2d');

faceMesh.onResults(results => {
    if (results.multiFaceLandmarks && results.multiFaceLandmarks.length > 0) {
        const landmarks = results.multiFaceLandmarks[0];
        // Forehead center approx (Index 151)
        const pt = landmarks[151];
        
        // Draw Overlay point
        const ovCanvas = document.getElementById('overlay-canvas');
        const ovCtx = ovCanvas.getContext('2d');
        ovCtx.clearRect(0,0,ovCanvas.width, ovCanvas.height);
        
        // Mirror coords for overlay drawing
        const x = (1 - pt.x) * ovCanvas.width; 
        const y = pt.y * ovCanvas.height;
        
        ovCtx.fillStyle = '#00ffcc';
        ovCtx.beginPath(); ovCtx.arc(x, y, 4, 0, 2*Math.PI); ovCtx.fill();

        // Extract Green Channel
        const vid = document.getElementById('input-video');
        if(vid.videoWidth > 0) {
            // Map normalized coord to video dimensions
            const vx = Math.floor(pt.x * vid.videoWidth);
            const vy = Math.floor(pt.y * vid.videoHeight);
            
            // Draw tiny crop
            pxCtx.drawImage(vid, vx-5, vy-5, 10, 10, 0, 0, 10, 10);
            const frame = pxCtx.getImageData(0,0,10,10);
            let avgG = 0;
            for(let i=0; i<frame.data.length; i+=4) avgG += frame.data[i+1];
            avgG /= (frame.data.length/4);

            // Add to buffer
            rawGreenBuffer.push({ t: performance.now(), v: avgG });
            if(rawGreenBuffer.length > MAX_SAMPLES * 2) rawGreenBuffer.shift(); // Keep buffer manageable
        }
        document.getElementById('status-display').innerText = "SIGNAL ACQUIRED";
        document.getElementById('status-display').style.color = "#00ffcc";
    } else {
        document.getElementById('status-display').innerText = "NO FACE";
        document.getElementById('status-display').style.color = "#ff0000";
    }
});

// --- MediaPipe Hands (Gestures) ---
const hands = new Hands({locateFile: (file) => `https://cdn.jsdelivr.net/npm/@mediapipe/hands/${file}`});
hands.setOptions({maxNumHands: 2, minDetectionConfidence: 0.7, minTrackingConfidence: 0.5});

hands.onResults(results => {
    if(results.multiHandLandmarks && results.multiHandLandmarks.length > 0) {
        let totalRatio = 0;
        results.multiHandLandmarks.forEach(lm => {
            // Distance Wrist(0) to MiddleTip(12)
            const d1 = Math.hypot(lm[12].x - lm[0].x, lm[12].y - lm[0].y);
            // Distance Wrist(0) to MiddleMCP(9) - roughly palm size
            const d2 = Math.hypot(lm[9].x - lm[0].x, lm[9].y - lm[0].y);
            
            // Ratio: > 1.8 is open, < 1.0 is closed
            const ratio = d1/d2;
            let closed = (1.8 - ratio); // Simple remapping
            closed = Math.max(0, Math.min(1, closed)); // Clamp 0-1
            totalRatio += closed;
        });
        const avg = totalRatio / results.multiHandLandmarks.length;
        // Smooth transition
        handTension += (avg - handTension) * 0.1;
    } else {
        handTension += (0 - handTension) * 0.05;
    }
});

// --- Camera ---
const cameraObj = new Camera(document.getElementById('input-video'), {
    onFrame: async () => {
        const vid = document.getElementById('input-video');
        await faceMesh.send({image: vid});
        await hands.send({image: vid});
    },
    width: 320, height: 240
});
cameraObj.start().then(() => document.getElementById('loader').style.display='none');


/**
 * SECTION 4: PROCESS LOOP (FFT & VISUALS)
 */

function runSignalProcessing() {
    if(rawGreenBuffer.length < 60) return; // Wait for data

    // 1. Resample to fixed 30Hz
    const now = performance.now();
    const duration = 1000 / TARGET_FPS; 
    const resampled = [];
    
    // We want the last N samples at fixed intervals
    // Start time:
    let t = rawGreenBuffer[rawGreenBuffer.length-1].t;
    
    // Backtrack MAX_SAMPLES steps
    for(let i=0; i<MAX_SAMPLES; i++) {
        const targetT = t - (i * duration);
        
        // Find closest points in raw buffer
        // Simple linear search (optimization: binary search)
        let p1 = rawGreenBuffer.find(p => p.t <= targetT); 
        // Note: raw buffer is time ascending. 
        // Actually, reverse search is better here.
        let idx = rawGreenBuffer.length - 1;
        while(idx >= 0 && rawGreenBuffer[idx].t > targetT) idx--;
        
        if(idx >= 0 && idx < rawGreenBuffer.length - 1) {
            const v0 = rawGreenBuffer[idx];
            const v1 = rawGreenBuffer[idx+1];
            // Lerp
            const fraction = (targetT - v0.t) / (v1.t - v0.t);
            resampled.unshift(v0.v + (v1.v - v0.v) * fraction);
        } else {
            resampled.unshift(0); // Padding
        }
    }

    // 2. Remove DC Offset (Detrend)
    const mean = resampled.reduce((a,b)=>a+b, 0) / resampled.length;
    const normalized = resampled.map(v => v - mean);

    // 3. Apply Window Function (Hamming) to reduce spectral leakage
    const windowed = normalized.map((v, i) => {
        return v * (0.54 - 0.46 * Math.cos((2 * Math.PI * i) / (MAX_SAMPLES - 1)));
    });

    // 4. Run FFT
    const spectrum = computeFFT(windowed);

    // 5. Find Peak Frequency in Heart Range (45 - 200 BPM)
    // Resolution = SampleRate / N = 30 / 512 = 0.058 Hz per bin
    const binSize = TARGET_FPS / MAX_SAMPLES;
    const minBin = Math.floor(0.75 / binSize); // 45 BPM
    const maxBin = Math.floor(3.5 / binSize);  // 210 BPM
    
    let maxMag = 0;
    let peakBin = 0;

    for(let i=minBin; i<=maxBin; i++) {
        if(spectrum[i] > maxMag) {
            maxMag = spectrum[i];
            peakBin = i;
        }
    }

    // 6. Calculate BPM
    const freq = peakBin * binSize;
    const newBPM = freq * 60;

    // Smooth Display
    if(maxMag > 10) { // Noise threshold
        detectedBPM = detectedBPM * 0.8 + newBPM * 0.2;
        document.getElementById('bpm-display').innerText = Math.round(detectedBPM);
    }

    // 7. Visual Debug
    drawDebug(normalized, spectrum, peakBin, minBin, maxBin);
}

function drawDebug(signal, spectrum, peakBin, min, max) {
    // Signal
    const w = signalCtx.canvas.width;
    const h = signalCtx.canvas.height;
    signalCtx.clearRect(0,0,w,h);
    signalCtx.strokeStyle = '#00ffcc';
    signalCtx.beginPath();
    for(let i=0; i<signal.length; i++) {
        const x = (i/signal.length) * w;
        const y = h/2 - (signal[i] * 5); // Scale
        if(i==0) signalCtx.moveTo(x,y); else signalCtx.lineTo(x,y);
    }
    signalCtx.stroke();

    // FFT
    fftCtx.clearRect(0,0,w,h);
    fftCtx.fillStyle = '#ff3366';
    const barW = w / (max - min);
    for(let i=min; i<max; i++) {
        const val = spectrum[i] / 50; // Scale
        const x = (i-min) * barW;
        fftCtx.fillRect(x, h - val, barW-1, val);
        if(i === peakBin) {
            fftCtx.fillStyle = '#ffffff'; // Highlight peak
            fftCtx.fillRect(x, h - val, barW-1, val);
            fftCtx.fillStyle = '#ff3366';
        }
    }
}

// Run processing 4 times a second
setInterval(runSignalProcessing, 250);


/**
 * SECTION 5: ANIMATION LOOP
 */
let pulsePhase = 0;

function animate() {
    requestAnimationFrame(animate);

    // Update Pulse
    // We increment phase based on detected BPM
    // Phase 0 to 2PI
    const bpm = detectedBPM || 60;
    const bps = bpm / 60;
    const speed = bps * 2 * Math.PI * 0.016; // per frame approx
    pulsePhase += speed;
    
    // Heartbeat curve (sudden expansion, slow decay)
    // sin wave modified to be "thumpy"
    const rawSine = Math.sin(pulsePhase); 
    const beat = Math.pow(Math.max(0, rawSine), 8); // Sharpen the peak

    // Update Particles
    const pos = pGeom.attributes.position;
    const col = pGeom.attributes.color;
    
    // Dynamic resizing based on beat
    const beatScale = 1 + (beat * 0.3 * handTension); // Only pulse when heart forms

    for(let i=0; i<particleCount; i++) {
        // Source (Random)
        const rx = pRandom[i*3];
        const ry = pRandom[i*3+1];
        const rz = pRandom[i*3+2];
        
        // Target (Heart)
        const tx = pTarget[i*3] * beatScale;
        const ty = pTarget[i*3+1] * beatScale;
        const tz = pTarget[i*3+2] * beatScale;

        // Lerp based on hand tension
        const cx = rx + (tx - rx) * handTension;
        const cy = ry + (ty - ry) * handTension;
        const cz = rz + (tz - rz) * handTension;

        // Add floaty noise
        const time = Date.now() * 0.0005;
        const nX = Math.sin(time + ry*0.1) * 0.2 * (1-handTension); // More float when open
        
        pos.setXYZ(i, cx + nX, cy, cz);

        // Colors
        // Lerp Blue -> Red
        const r = colOpen.r + (colHeart.r - colOpen.r) * handTension;
        const g = colOpen.g + (colHeart.g - colOpen.g) * handTension;
        const b = colOpen.b + (colHeart.b - colOpen.b) * handTension;
        
        // Brighten on beat
        const bright = 1 + (beat * handTension);
        col.setXYZ(i, r*bright, g*bright, b*bright);
    }

    pos.needsUpdate = true;
    col.needsUpdate = true;
    
    scene.rotation.y += 0.002;

    // Overlay Canvas Resize Check
    const ov = document.getElementById('overlay-canvas');
    const vid = document.getElementById('input-video');
    if(ov.width !== vid.videoWidth && vid.videoWidth > 0) {
        ov.width = vid.videoWidth;
        ov.height = vid.videoHeight;
    }

    renderer.render(scene, camera);
}

animate();

// Resize
window.addEventListener('resize', () => {
    camera.aspect = window.innerWidth / window.innerHeight;
    camera.updateProjectionMatrix();
    renderer.setSize(window.innerWidth, window.innerHeight);
});

</script>
</body>
</html>
