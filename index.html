<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Bio-Interactive Particle System</title>
    <style>
        body { margin: 0; overflow: hidden; background: #000; font-family: 'Segoe UI', sans-serif; }
        
        /* Main 3D Canvas */
        #c { width: 100vw; height: 100vh; display: block; }

        /* UI Overlay - Heart Rate (Top Right) */
        #hr-container {
            position: absolute; top: 20px; right: 20px;
            color: #00ff88; background: rgba(0, 20, 10, 0.8);
            padding: 15px; border-radius: 10px; border: 1px solid #00ff88;
            text-align: right; pointer-events: none;
        }
        #bpm-display { font-size: 3rem; font-weight: bold; }
        #bpm-label { font-size: 0.8rem; text-transform: uppercase; letter-spacing: 2px; }

        /* UI Overlay - Webcam (Bottom Right) */
        #webcam-container {
            position: absolute; bottom: 20px; right: 20px;
            width: 240px; height: 180px;
            border-radius: 10px; overflow: hidden;
            border: 2px solid rgba(255, 255, 255, 0.2);
            z-index: 10;
        }
        #input_video {
            width: 100%; height: 100%; object-fit: cover; transform: scaleX(-1);
        }

        /* Status / Instructions */
        #status {
            position: absolute; top: 20px; left: 20px;
            color: rgba(255, 255, 255, 0.7); pointer-events: none;
        }

        /* Hidden Canvas for PPG processing */
        #ppg-canvas { display: none; }
    </style>
    
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.js"></script>
</head>
<body>

    <div id="status">
        <h3>System Ready</h3>
        <p>Make a <strong>fist</strong> to form the heart and start HR.</p>
        <p>Relax or open your hand to dissipate the particles.</p>
    </div>

    <div id="hr-container">
        <div id="bpm-display">--</div>
        <div id="bpm-label">Heart Rate (BPM)</div>
    </div>

    <div id="webcam-container">
        <video id="input_video" autoplay playsinline></video>
    </div>

    <canvas id="ppg-canvas"></canvas>
    
    <canvas id="c"></canvas>

<script>
/**
 * PART 1: THREE.JS SETUP & PARTICLE SYSTEM
 */
const canvas = document.querySelector('#c');
const renderer = new THREE.WebGLRenderer({canvas, antialias: true, alpha: true});
renderer.setSize(window.innerWidth, window.innerHeight);

const camera = new THREE.PerspectiveCamera(
    75,
    window.innerWidth / window.innerHeight,
    0.1,
    1000
);
camera.position.z = 30;
camera.lookAt(0, 0, 0); // Centre screen focus

const scene = new THREE.Scene();
scene.fog = new THREE.FogExp2(0x000000, 0.02);

// Particle Configuration
const PARTICLE_COUNT = 8000;
const geometry = new THREE.BufferGeometry();
const positions = new Float32Array(PARTICLE_COUNT * 3);
const velocities = new Float32Array(PARTICLE_COUNT * 3);
const heartBasePositions = new Float32Array(PARTICLE_COUNT * 3); // Stable heart template

// Random starting positions (cloud)
for (let i = 0; i < PARTICLE_COUNT * 3; i++) {
    positions[i] = (Math.random() - 0.5) * 60;
    velocities[i] = (Math.random() - 0.5) * 0.5;
}
geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));

/**
 * Build a SOLID, DENSE, UPRIGHT HEART as a 3D volume.
 * - Use implicit 2D heart equation: (x^2 + y^2 - 1)^3 - x^2 y^3 <= 0
 * - Sample on a 3D grid, keep only inside points
 * - Subsample to exactly PARTICLE_COUNT, so it looks visually "fully filled".
 */
(function initHeartShape() {
    const scaleXY = 9.0;   // scale for x,y
    const scaleZ  = 4.0;   // thickness in z

    const gridN = 26; // 26^3 = 17,576 candidates, plenty to choose from
    const candidates = [];

    for (let ix = 0; ix < gridN; ix++) {
        const x2d = -1 + (2 * ix) / (gridN - 1); // -1..1

        for (let iy = 0; iy < gridN; iy++) {
            const y2d = -1.3 + (2.6 * iy) / (gridN - 1); // -1.3..1.3 (slightly taller)

            // Implicit 2D heart test
            const x2 = x2d * x2d;
            const y2 = y2d * y2d;
            const a  = x2 + y2 - 1;
            const heartVal = a * a * a - x2 * y2d * y2d * y2d;

            if (heartVal > 0) continue; // outside -> reject

            for (let iz = 0; iz < gridN; iz++) {
                const z2d = -1 + (2 * iz) / (gridN - 1); // -1..1

                // Store candidate in local heart coordinates
                candidates.push({
                    x: x2d * scaleXY,
                    y: y2d * scaleXY,   // upright: lobes up, point down
                    z: z2d * scaleZ     // extruded thickness
                });
            }
        }
    }

    // If somehow not enough (unlikely), fallback to random fill
    if (candidates.length < PARTICLE_COUNT) {
        console.warn('Not enough heart candidates, falling back to random fill');
        for (let i = 0; i < PARTICLE_COUNT; i++) {
            const i3 = i * 3;
            heartBasePositions[i3]     = (Math.random() - 0.5) * scaleXY * 2;
            heartBasePositions[i3 + 1] = (Math.random() - 0.5) * scaleXY * 2;
            heartBasePositions[i3 + 2] = (Math.random() - 0.5) * scaleZ * 2;
        }
        return;
    }

    // Subsample candidates evenly to fill exactly PARTICLE_COUNT slots.
    // This gives a dense lattice-like fill with minimal visible gaps.
    for (let i = 0; i < PARTICLE_COUNT; i++) {
        const i3 = i * 3;
        const idx = Math.floor((i / (PARTICLE_COUNT - 1)) * (candidates.length - 1));
        const c = candidates[idx];

        heartBasePositions[i3]     = c.x;
        heartBasePositions[i3 + 1] = c.y;
        heartBasePositions[i3 + 2] = c.z;
    }
})();

// Particle Material
const circleCanvas = document.createElement('canvas');
circleCanvas.width = 32;
circleCanvas.height = 32;
const ctx = circleCanvas.getContext('2d');
ctx.beginPath();
ctx.arc(16, 16, 15, 0, 2 * Math.PI);
ctx.fillStyle = '#ffffff';
ctx.fill();
const sprite = new THREE.CanvasTexture(circleCanvas);

const material = new THREE.PointsMaterial({
    size: 0.3,
    map: sprite,
    color: 0xff2266,
    transparent: true,
    opacity: 0.9,
    blending: THREE.AdditiveBlending,
    depthWrite: false
});

const particleSystem = new THREE.Points(geometry, material);
particleSystem.position.set(0, 0, 0); // centre at origin
scene.add(particleSystem);

// Logic Variables
let handDetected = false;
let lastHandTime = 0;
let heartActive = false;     // true when fist is detected

// Heartbeat animation state
let currentBpm = 60;         // smoothed BPM for animation
let heartPhase = 0;          // phase of heartbeat
let lastFrameTime = performance.now();


/**
 * PART 2: MEDIAPIPE HAND TRACKING & GESTURE LOGIC
 */
const videoElement = document.getElementById('input_video');

function onResults(results) {
    const hands = results.multiHandLandmarks;

    if (hands && hands.length > 0) {
        handDetected = true;
        lastHandTime = Date.now();

        // Gesture detection for FIST (heart on) vs other (heart off)
        const lm = hands[0];

        const isFingerCurled = (tipIdx, pipIdx) => {
            const dTip = Math.sqrt(
                Math.pow(lm[tipIdx].x - lm[0].x, 2) +
                Math.pow(lm[tipIdx].y - lm[0].y, 2)
            );
            const dPip = Math.sqrt(
                Math.pow(lm[pipIdx].x - lm[0].x, 2) +
                Math.pow(lm[pipIdx].y - lm[0].y, 2)
            );
            return dTip < dPip;
        };

        const thumbOpen  = !isFingerCurled(4, 2);
        const indexOpen  = !isFingerCurled(8, 6);
        const middleOpen = !isFingerCurled(12, 10);
        const ringOpen   = !isFingerCurled(16, 14);
        const pinkyOpen  = !isFingerCurled(20, 18);

        const fingersOpenCount = [thumbOpen, indexOpen, middleOpen, ringOpen, pinkyOpen]
            .filter(Boolean).length;

        // Fist = heart ON, everything else = heart OFF
        if (fingersOpenCount <= 1) {
            heartActive = true;
            material.color.setHex(0xff2266);
        } else {
            heartActive = false;
            material.color.setHex(0x00ffff);
        }
    } else {
        handDetected = false;
        heartActive = false;
    }
}

const hands = new Hands({
    locateFile: (file) => `https://cdn.jsdelivr.net/npm/@mediapipe/hands/${file}`
});

hands.setOptions({
    maxNumHands: 2,
    modelComplexity: 1,
    minDetectionConfidence: 0.5,
    minTrackingConfidence: 0.5
});
hands.onResults(onResults);


/**
 * PART 3: PPG HEART RATE MONITOR (FOREHEAD ROI, STABLE BPM)
 */
const ppgCanvas = document.getElementById('ppg-canvas');
const ppgCtx = ppgCanvas.getContext('2d', { willReadFrequently: true });
const bpmDisplay = document.getElementById('bpm-display');

const signalBuffer = [];
const BUFFER_SIZE = 240; // ~8s at 30 fps – more stable
let lastBPMPulses = [];
let lastBpmCalcTime = 0;
const BPM_UPDATE_INTERVAL = 900; // ms between BPM calculations

function processPPG() {
    if (videoElement.paused || videoElement.ended) return;

    ppgCanvas.width = videoElement.videoWidth;
    ppgCanvas.height = videoElement.videoHeight;

    // Draw frame
    ppgCtx.drawImage(videoElement, 0, 0, ppgCanvas.width, ppgCanvas.height);

    // Forehead ROI (top center)
    const roiX = Math.floor(ppgCanvas.width * 0.4);
    const roiY = Math.floor(ppgCanvas.height * 0.1);
    const roiW = Math.floor(ppgCanvas.width * 0.2);
    const roiH = Math.floor(ppgCanvas.height * 0.15);

    const frameData = ppgCtx.getImageData(roiX, roiY, roiW, roiH);
    const data = frameData.data;

    let greenSum = 0;
    for (let i = 0; i < data.length; i += 4) {
        greenSum += data[i + 1];
    }
    const greenAvg = greenSum / (data.length / 4);

    const now = Date.now();
    signalBuffer.push({ t: now, val: greenAvg });
    if (signalBuffer.length > BUFFER_SIZE) signalBuffer.shift();

    if (
        signalBuffer.length === BUFFER_SIZE &&
        now - lastBpmCalcTime > BPM_UPDATE_INTERVAL
    ) {
        calculateBPM();
        lastBpmCalcTime = now;
    }
}

function calculateBPM() {
    const values = signalBuffer.map((s) => s.val);

    // Detrend: moving average
    const windowSize = 15;
    const cleanSignal = [];
    for (let i = 0; i < values.length; i++) {
        let sum = 0;
        let count = 0;
        for (
            let j = Math.max(0, i - windowSize);
            j < Math.min(values.length, i + windowSize);
            j++
        ) {
            sum += values[j];
            count++;
        }
        cleanSignal.push(values[i] - sum / count);
    }

    // Dynamic threshold: mean + k * std
    const mean =
        cleanSignal.reduce((a, b) => a + b, 0) / cleanSignal.length;
    const variance =
        cleanSignal.reduce((a, b) => a + Math.pow(b - mean, 2), 0) /
        cleanSignal.length;
    const std = Math.sqrt(variance);
    const threshold = mean + 0.4 * std;

    // Peak times via local maxima
    const peakTimes = [];
    for (let i = 1; i < cleanSignal.length - 1; i++) {
        if (
            cleanSignal[i] > cleanSignal[i - 1] &&
            cleanSignal[i] > cleanSignal[i + 1] &&
            cleanSignal[i] > threshold
        ) {
            peakTimes.push(signalBuffer[i].t);
        }
    }

    if (peakTimes.length < 2) return;

    // Average RR interval
    let intervals = [];
    for (let i = 1; i < peakTimes.length; i++) {
        intervals.push((peakTimes[i] - peakTimes[i - 1]) / 1000); // seconds
    }
    const avgInterval =
        intervals.reduce((a, b) => a + b, 0) / intervals.length;

    if (avgInterval <= 0) return;

    let bpm = 60 / avgInterval;
    bpm = Math.round(bpm);

    // Reasonable HR bounds
    if (bpm < 40 || bpm > 200) return;

    // Smooth BPM for display & animation
    lastBPMPulses.push(bpm);
    if (lastBPMPulses.length > 6) lastBPMPulses.shift();
    const avgBpm =
        lastBPMPulses.reduce((a, b) => a + b, 0) / lastBPMPulses.length;

    currentBpm = currentBpm * 0.7 + avgBpm * 0.3;
    bpmDisplay.innerText = Math.round(currentBpm);
}


/**
 * PART 4: CAMERA + HANDS + PPG LOOP
 */
const cameraUtils = new Camera(videoElement, {
    onFrame: async () => {
        await hands.send({ image: videoElement });

        // Only run PPG when the heart is active (fist)
        if (heartActive) {
            processPPG();
        }
    },
    width: 640,
    height: 480
});
cameraUtils.start();


/**
 * PART 5: ANIMATION LOOP – HEART FORMATION + BEATING
 * No rotation anywhere, just morphing between cloud and heart.
 */
function animate() {
    requestAnimationFrame(animate);

    const now = performance.now();
    const delta = (now - lastFrameTime) / 1000;
    lastFrameTime = now;

    const positionsArray = geometry.attributes.position.array;

    // Heartbeat phase advances according to BPM
    const bpmForAnim = Math.max(40, Math.min(180, currentBpm || 60));
    const freq = bpmForAnim / 60; // Hz
    heartPhase += freq * 2 * Math.PI * delta;
    const beatScale = 1.0 + 0.18 * Math.sin(heartPhase); // 18% expansion

    // If no hand for > 2s, dissipate
    const dissipating =
        !handDetected && Date.now() - lastHandTime > 2000;

    for (let i = 0; i < PARTICLE_COUNT; i++) {
        const i3 = i * 3;

        if (heartActive && !dissipating) {
            // Move towards dense HEART volume, scaled only by heartbeat
            const targetX = heartBasePositions[i3] * beatScale;
            const targetY = heartBasePositions[i3 + 1] * beatScale;
            const targetZ = heartBasePositions[i3 + 2] * beatScale;

            positionsArray[i3]     += (targetX - positionsArray[i3]) * 0.2;
            positionsArray[i3 + 1] += (targetY - positionsArray[i3 + 1]) * 0.2;
            positionsArray[i3 + 2] += (targetZ - positionsArray[i3 + 2]) * 0.2;

            // Prep velocities for next dispersion phase
            velocities[i3]     = (Math.random() - 0.5) * 0.4;
            velocities[i3 + 1] = (Math.random() - 0.5) * 0.4;
            velocities[i3 + 2] = (Math.random() - 0.5) * 0.4;
        } else {
            // Dissipated / cloud state
            positionsArray[i3]     += velocities[i3];
            positionsArray[i3 + 1] += velocities[i3 + 1] - 0.01; // gentle "fall"
            positionsArray[i3 + 2] += velocities[i3 + 2];

            // Soft boundary to keep them in view
            const r = 80;
            if (positionsArray[i3] > r || positionsArray[i3] < -r) {
                velocities[i3] *= -0.7;
            }
            if (positionsArray[i3 + 1] > r || positionsArray[i3 + 1] < -r) {
                velocities[i3 + 1] *= -0.7;
            }
            if (positionsArray[i3 + 2] > r || positionsArray[i3 + 2] < -r) {
                velocities[i3 + 2] *= -0.7;
            }

            // Gentle random walk
            velocities[i3]     += (Math.random() - 0.5) * 0.01;
            velocities[i3 + 1] += (Math.random() - 0.5) * 0.01;
            velocities[i3 + 2] += (Math.random() - 0.5) * 0.01;
        }
    }

    geometry.attributes.position.needsUpdate = true;

    // No rotation at all:
    // particleSystem.rotation.set(0, 0, 0);

    renderer.render(scene, camera);
}

// Resize handling
window.addEventListener('resize', () => {
    renderer.setSize(window.innerWidth, window.innerHeight);
    camera.aspect = window.innerWidth / window.innerHeight;
    camera.updateProjectionMatrix();
});

animate();
</script>
</body>
</html>
